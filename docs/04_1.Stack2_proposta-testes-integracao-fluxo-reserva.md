# Proposta de Testes de Integração – Fluxo Reserva (Stack 2: Java + Spring)

**Objetivo**: Validar o fluxo completo via API REST:
**Cadastro de hóspede → Criação de reserva → Atualização de disponibilidade do quarto**

---

## 1. Contexto e pré-requisitos

### 1.1 Requisitos atendidos (RF)

| RF     | Descrição |
|--------|-----------|
| RF-02.1 | Cadastro de hóspede com nome, sobrenome, CPF e e-mail |
| RF-03.2 | Criar reservas associando quarto e hóspede |
| RF-04.1 | Impedir reserva de quarto ocupado ou em manutenção/limpeza |
| RF-04.2 | Atualizar disponibilidade do quarto ao criar/alterar/cancelar reserva |

### 1.2 Dependências para implementação

Os testes pressupõem que existam as rotas:

- `POST /hospedes` — cadastro de hóspede
- `POST /reservas` — criação de reserva
- `PATCH /quartos/{id}/status` — alteração de status do quarto (já existe)
- `GET /quartos/{id}` — consulta de quarto (já existe)

**Pré-requisito**: Implementar os módulos **Hospede** e **Reserva** (controllers, services, repositories, DTOs).

### 1.3 Stack de testes sugerida

- **@SpringBootTest** — carrega contexto completo da aplicação
- **MockMvc** — simula chamadas HTTP sem levantar servidor real
- **H2 in-memory** — banco em memória para testes (já configurado em `application.properties`)
- **JUnit 5** + **AssertJ** — runner e asserções (incluídos em `spring-boot-starter-test`)

---

## 2. Estratégia de teste

### 2.1 Escopo

Testes de **integração** que exercitam:

1. **API REST** (Controllers + rotas)
2. **Services** (lógica de negócio)
3. **Repositories JPA** (persistência H2)
4. **Fluxo transacional** entre módulos (Hospede → Reserva → Quarto)

### 2.2 Configuração do banco de testes

- Usar H2 em memória com `spring.datasource.url=jdbc:h2:mem:testdb` em `application-test.properties`
- `@Transactional` em cada teste (ou `@DirtiesContext`) para isolamento — cada teste inicia com banco limpo

### 2.3 Sequência esperada (fluxo feliz)

```
1. POST /quartos     → criar quarto (status LIVRE)
2. POST /hospedes    → cadastrar hóspede
3. GET  /quartos/{id} → quarto com status LIVRE
4. POST /reservas    → criar reserva (quarto + hóspede)
5. GET  /quartos/{id} → quarto com status OCUPADO
```

---

## 3. Casos de teste propostos

### 3.1 Fluxo feliz (happy path)

| ID   | Descrição | Pré-condições | Ações | Asserções |
|------|-----------|---------------|-------|-----------|
| IT-01 | Fluxo completo: cadastrar hóspede, criar reserva e verificar quarto OCUPADO | Quarto 101 cadastrado (LIVRE) | 1. POST hospede<br>2. POST reserva (quarto 101, hospede)<br>3. GET quarto 101 | 1. Hospede retorna 201 e id<br>2. Reserva retorna 201 e id<br>3. Quarto com status OCUPADO |

### 3.2 Regras de negócio (RF-04)

| ID   | Descrição | Pré-condições | Ações | Asserções |
|------|-----------|---------------|-------|-----------|
| IT-02 | Impedir reserva de quarto OCUPADO (RF-04.1) | Quarto 102 com status OCUPADO | POST reserva (quarto 102, hospede) | 400 Bad Request, mensagem indicando quarto indisponível |
| IT-03 | Impedir reserva de quarto em MANUTENCAO_LIMPEZA (RF-04.1) | Quarto 103 com status MANUTENCAO_LIMPEZA | POST reserva (quarto 103, hospede) | 400 Bad Request, quarto indisponível |
| IT-04 | Quarto LIVRE volta a LIVRE após cancelar reserva (RF-04.2) | Reserva ativa para quarto 104 | 1. PATCH reserva → cancelar<br>2. GET quarto 104 | 1. Reserva cancelada<br>2. Quarto com status LIVRE |

### 3.3 Validações e erros

| ID   | Descrição | Pré-condições | Ações | Asserções |
|------|-----------|---------------|-------|-----------|
| IT-05 | Reserva com quarto inexistente | Hospede cadastrado | POST reserva (quartoId: 99999, hospede) | 404 Not Found |
| IT-06 | Reserva com hóspede inexistente | Quarto cadastrado | POST reserva (quarto, hospedeId: 99999) | 404 Not Found |
| IT-07 | Cadastro de hóspede com dados inválidos | — | POST hospede (CPF inválido, email inválido) | 400 Bad Request |
| IT-08 | Reserva com data fim anterior à data início | Quarto e hospede cadastrados | POST reserva (dataFim < dataInicio) | 400 Bad Request |

### 3.4 Consistência entre módulos

| ID   | Descrição | Pré-condições | Ações | Asserções |
|------|-----------|---------------|-------|-----------|
| IT-09 | Reserva criada referencia quarto e hóspede corretos | Quarto 105 e hospede cadastrados | POST reserva → GET reserva | Campos quartoId, hospedeId corretos |
| IT-10 | Múltiplas reservas em quartos diferentes não interferem | 2 quartos LIVRE, 2 hospedes | 2x POST reserva (quarto1, hospede1) e (quarto2, hospede2) | Ambos quartos OCUPADO; reservas independentes |

---

## 4. Estrutura do arquivo de teste

```
stack2/
├── src/
│   ├── main/
│   │   └── ...
│   └── test/
│       ├── java/com/hotel/
│       │   └── integration/
│       │       └── FluxoReservaIntegrationTest.java
│       └── resources/
│           └── application-test.properties
```

### 4.1 Configuração de perfil de teste

**`src/test/resources/application-test.properties`**:

```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=false
```

### 4.2 Template sugerido (JUnit 5 + MockMvc)

```java
package com.hotel.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.hamcrest.Matchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@Transactional  // rollback após cada teste
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class FluxoReservaIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    private Long quartoId;
    private Long hospedeId;

    @BeforeEach
    void setUp() throws Exception {
        // 1. Cadastrar quarto
        var quartoJson = """
                {"numero":"101","tipo":"BASICO","capacidade":2,"precoDiaria":150}
                """;
        var resultQuarto = mockMvc.perform(post("/quartos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(quartoJson))
                .andExpect(status().isCreated())
                .andReturn();
        quartoId = objectMapper.readTree(resultQuarto.getResponse().getContentAsString()).get("id").asLong();

        // 2. Cadastrar hóspede
        var hospedeJson = """
                {"nome":"João","sobrenome":"Silva","cpf":"12345678901","email":"joao@email.com"}
                """;
        var resultHospede = mockMvc.perform(post("/hospedes")
                .contentType(MediaType.APPLICATION_JSON)
                .content(hospedeJson))
                .andExpect(status().isCreated())
                .andReturn();
        hospedeId = objectMapper.readTree(resultHospede.getResponse().getContentAsString()).get("id").asLong();
    }

    @Test
    @Order(1)
    void IT01_fluxoCompleto_cadastrarHospedeCriarReserva_quartoFicaOcupado() throws Exception {
        // GET quarto: status LIVRE
        mockMvc.perform(get("/quartos/{id}", quartoId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("LIVRE"));

        // POST reserva
        var reservaJson = """
                {"quartoId":%d,"hospedeId":%d,"dataInicio":"2025-02-10","dataFim":"2025-02-12"}
                """.formatted(quartoId, hospedeId);
        mockMvc.perform(post("/reservas")
                .contentType(MediaType.APPLICATION_JSON)
                .content(reservaJson))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").exists())
                .andExpect(jsonPath("$.quartoId").value(quartoId))
                .andExpect(jsonPath("$.hospedeId").value(hospedeId));

        // GET quarto: status OCUPADO
        mockMvc.perform(get("/quartos/{id}", quartoId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("OCUPADO"));
    }

    @Test
    @Order(2)
    void IT02_quartoOcupado_naoPermiteReserva() throws Exception {
        // PATCH quarto → OCUPADO
        mockMvc.perform(patch("/quartos/{id}/status", quartoId)
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"status\":\"OCUPADO\"}"))
                .andExpect(status().isOk());

        var reservaJson = """
                {"quartoId":%d,"hospedeId":%d,"dataInicio":"2025-02-10","dataFim":"2025-02-12"}
                """.formatted(quartoId, hospedeId);
        mockMvc.perform(post("/reservas")
                .contentType(MediaType.APPLICATION_JSON)
                .content(reservaJson))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.erro", containsString("indisponível")));
    }

    // ... IT-03 a IT-10 seguindo o mesmo padrão
}
```

---

## 5. Ordem de implementação sugerida

| Ordem | Tarefa |
|-------|--------|
| 1 | Implementar módulos **Hospede** (Repository, Service, Controller, DTOs) |
| 2 | Implementar módulo **Reserva** (Repository, Service, Controller, DTOs) — incluindo regra RF-04.1 (quarto disponível) e RF-04.2 (atualizar status ao criar/cancelar) |
| 3 | Criar `application-test.properties` |
| 4 | Criar `FluxoReservaIntegrationTest` com casos IT-01 a IT-10 |

---

## 6. Resumo

| Aspecto | Proposta |
|---------|----------|
| **Tipo** | Testes de integração (API REST) |
| **Escopo** | Hospede + Reserva + Quarto (fluxo completo) |
| **Runner** | JUnit 5 |
| **Cliente HTTP** | MockMvc |
| **Banco** | H2 in-memory (perfil `test`) |
| **Casos** | 10 cenários (fluxo feliz, regras RF-04, validações, consistência) |
