<<**Arquivo gerado manualmente**>>

---

[2 tools called]


Segue a explicação da estratégia de cobertura de testes definida:

---

## Estratégia de cobertura de testes

A estratégia usa **dois níveis de testes** (pirâmide) e está descrita em `docs/04_2.Stack1_Estrategia_cobertura_testes.md`.

---

### 1. Pirâmide de testes (dois níveis)

| Nível | Tipo | Escopo | Ferramenta |
|-------|------|--------|------------|
| **Unitário** | Testes de unidade | Camada de aplicação (Services) | Jest + mocks (Stack 1) / JUnit + mocks (Stack 2) |
| **Integração** | Testes de integração | API REST completa (vários módulos) | Jest + supertest (Stack 1) / JUnit + MockMvc (Stack 2) |

A base é unitária (mais testes, mais rápidos); o topo é integração (menos testes, fluxos completos).

---

### 2. Cobertura unitária

**Objetivo**: Validar regras de negócio isoladas, sem rede nem banco.

**Abordagem**:
- Testar Services com dependências mockadas (ex.: Repository).
- Foco em operações como `cadastrar`, `editar`.

**Cenários**:
- **Caminho feliz**: sucesso com dados válidos, valores padrão.
- **Validação**: campos obrigatórios, formatos inválidos (número vazio, preço negativo).
- **Regras de negócio**: número duplicado, quarto inexistente.
- **Bordas**: ID obrigatório na edição, manter mesmo número ao editar.

**Rastreamento**:
- RF-04.5 (unicidade do número) → conflito em cadastro e edição.
- RF-01.1 / RF-01.4 → validações de formato.

---

### 3. Cobertura de integração

**Objetivo**: Validar o fluxo **Hóspede → Reserva → Quarto** via HTTP, sem mocks nas rotas.

**Abordagem**:
- Usar API REST real (Controllers, Services, Repositories).
- Banco em memória (H2 para Stack 2).
- Entrada e saída via HTTP (JSON).

**10 cenários**:
- **Fluxo feliz (1)**: IT-01 – fluxo completo funcionando.
- **Regras RF-04 (3)**: IT-02 a IT-04 – quarto indisponível, cancelamento libera quarto.
- **Validações/erros (4)**: IT-05 a IT-08 – recursos inexistentes, dados inválidos.
- **Consistência (2)**: IT-09 a IT-10 – referências corretas, isolamento entre reservas.

**Cobertura horizontal**:
- API REST (Controllers e rotas).
- Services (Quarto, Hospede, Reserva).
- Repositories (persistência).
- Fluxo transacional entre os módulos.

---

### 4. Critérios unitário vs integração

| Aspecto | Unitário | Integração |
|---------|----------|------------|
| **Granularidade** | Método/operação | Cenário completo |
| **Dependências** | Mockadas | Reais |
| **Entrada** | DTOs e entidades | HTTP (JSON) |
| **Saída** | Entidades e exceções | Status HTTP e corpo JSON |
| **Foco** | Regras isoladas | Fluxos e integração entre módulos |

---

### 5. Princípios da estratégia

1. **Unitário primeiro**: regras críticas cobertas com mocks e asserções claras.
2. **Integração depois**: fluxo Reserva/Hospede/Quarto validado via API.
3. **Categorização**: fluxo feliz, regras RF-04, validações e consistência.
4. **Rastreabilidade**: cenários ligados a RF-02, RF-03, RF-04.
5. **Sem redundância**: unitários cobrem lógica interna; integração cobrem fluxos e contrato da API.